<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="io.openthread.BorderRouter">
    <!-- Scan: Perform a Thread network scan.
      @scan_result: array of scan results.

      The result struture definition is:
      <literallayout>
        struct {
          uint64 ext_address
          string network_name
          uint64 ext_panid
          uint8[] steering_data
          uint16 panid
          uint16 joiner_udp_port
          uint8 channel
          int16 rssi
          uint8 lqi
          uint8 version
          bool is_native
          bool is_joinable
        }
      </literallayout>
    -->
    <method name="Scan">
      <arg name="scan_result" type="a(tstayqqynyybb)" direction="out"/>
    </method>

    <!-- Energy Scan: Perform a Thread energy scan.
      @scanDuration: The 32-bit duration time for the scan of each channel, in milliseconds.

      @result: array of energy scan results.

      The result struture definition is:
      <literallayout>
        struct {
          uint8  channel
          int8_t max_rssi
        }
      </literallayout>
    -->
    <method name="EnergyScan">
      <arg name="scanduration" type="u"/>
      <arg name="result" type="a(yy)" direction="out"/>
    </method>

    <!-- Attach: Attach the current device to the Thread network.
      @networkkey: The 128-bit network network key, empty for random.
      @panid: The 16-bit panid, UINT16_MAX for any.
      @networkname: The Thread network name.
      @extpanid: The 64-bit extended panid, UINT64_MAX for random.
      @pskc: The 128-bit pre-shared key for commissione, empty for random.
      @channel_mask: The bitwise channel mask, will randomly select a valid channel.

      You can also call this method with no arugment to use the current active network dataset.
    -->
    <method name="Attach">
      <arg name="networkkey" type="ay"/>
      <arg name="panid" type="q"/>
      <arg name="networkname" type="s"/>
      <arg name="extpanid" type="t"/>
      <arg name="pskc" type="ay"/>
      <arg name="channel_mask" type="u"/>
    </method>

    <!-- AttachAllNodesTo: Request to attach all nodes to the specified Thread network.
      @dataset: The Operational Dataset that contains parameter values of the Thread network
                to attach to. It must be a full dataset.
      @delay_ms: The delay between the method returns and the dataset takes effect, in
                 milliseconds. If this value is 0, then the node is attached to the given network
                 when this method returns. If this value is not 0, then the node is attached to
                 its existing network when this method returns, and will attach to the given
                 network after the delay.
    -->
    <method name="AttachAllNodesTo">
      <arg name="dataset" type="ay"/>
      <arg name="delay_ms" type="x" direction="out"/>
    </method>

    <!-- Detach: Detach the current device from the Thread network. -->
    <method name="Detach">
    </method>

    <!-- PermitUnsecureJoin: Allow joining the network via unsecure traffic temporarily.
      @port: The port of the unsecure traffic.
      @timeout: The timeout for the permission.
    -->
    <method name="PermitUnsecureJoin">
      <arg name="port" type="q"/>
      <arg name="timeout" type="u"/>
    </method>

    <!-- JoinerStart: Start Thread joining.
      @pskd: The pre-shared key for the device.
      @provision_url: The url for further provision.
      @vendor vendor_name: The current device vendor name.
      @vendor vendor_model: The current device model.
      @vendor vendor_sw_version: The current device software version.
      @vendor vendor_data: The additional vendor data.
    -->
    <method name="JoinerStart">
      <arg name="pskd" type="s"/>
      <arg name="provision_url" type="s"/>
      <arg name="vendor_name" type="s"/>
      <arg name="vendor_model" type="s"/>
      <arg name="vendor_sw_version" type="s"/>
      <arg name="vendor_data" type="s"/>
    </method>

    <!-- JoinerStop: Stop Thread joining. -->
    <method name="JoinerStop">
    </method>

    <!-- FactoryReset: Perform a factory reset, will wipe all Thread persistent data. -->
    <method name="FactoryReset">
    </method>

    <!-- Reset: Perform a reset, will try to resume the network after reset. -->
    <method name="Reset">
    </method>

    <!-- AddExternalRoute: Add an external border routing rule to the network.
      @prefix: The prefix for border routing.

      This will make the current device act as the border router for the prefix.
      The prefix structure is:
      <literallayout>
        struct {
          struct {
            uint8[] prefix_bytes
            uint8 prefix_length
          }
          uint16 rloc // Not used
          uint8 preference
          bool stable
          bool next_hop_is_self // Not used
        }
      </literallayout>
    -->
    <method name="AddExternalRoute">
      <arg name="prefix" type="((ayy)qybb)"/>
    </method>

    <!-- RemoveExternalRoute: Remove an external border routing rule from the network.
      @prefix: The prefix for border routing.

      The prefix structure is:
      <literallayout>
        struct {
          uint8[] prefix_bytes
          uint8 prefix_length
        }
      </literallayout>
    -->
    <method name="RemoveExternalRoute">
      <arg name="prefix" type="(ayy)"/>
    </method>

    <!-- AddOnMeshPrefix: Add an on-mesh prefix to the network.
      @prefix: The on-mesh prefix.

      The on-mesh prefix structure is:
      <literallayout>
        struct {
          struct {
            uint8[] prefix_bytes
            uint8 prefix_length
          }
          uint16 rloc16
          byte preference
          bool preferred
          bool slaac
          bool dhcp
          bool configure
          bool default_route
          bool on_mesh
          bool stable
          bool nd_dns
          bool dp
        }
      </literallayout>
    -->
    <method name="AddOnMeshPrefix">
      <arg name="prefix" type="((ayy)qybbbbbbbbb)"/>
    </method>

    <!-- RemoveOnMeshPrefix: Remove an on-mesh prefix from the network.
      @prefix: The on-mesh prefix.

      The prefix structure is:
      <literallayout>
        struct {
          uint8[] prefix_bytes
          uint8 prefix_length
        }
      </literallayout>
    -->
    <method name="RemoveOnMeshPrefix">
      <arg name="prefix" type="(ayy)"/>
    </method>

    <!-- UpdateMeshCopTxt: Update multiple entries in the TXT record.
      @key: The key of the entry.
      @value: The value of the entry.

      The prefix structure is:
      <literallayout>
        struct {
          string key
          uint8[] value
        }
      </literallayout>
    -->
    <method name="UpdateVendorMeshCopTxtEntries">
      <arg name="update" type="a(say)" direction="in"/>
    </method>

    <!-- GetProperties: Get one or more OpenThread properties.
      @properties: Names of properties.
    -->
    <method name="GetProperties">
      <arg name="properties" type="as" direction="in"/>
    </method>

    <!-- LeaveNetwork: Detach from the network and forget the credentials. -->
    <method name="LeaveNetwork">
    </method>

    <method name="SetNat64Enabled">
      <arg name="enable" type="b" direction="in"/>
    </method>

    <property name="EphemeralKeyEnabled" type="b" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ActivateEphemeralKeyMode: Activate ePSKc mode.
      @lifetime: in milliseconds, duration of active ePSKc mode before secure session is established.
                 0 for OT_BORDER_AGENT_DEFAULT_EPHEMERAL_KEY_TIMEOUT (2 min).
      @epskc: returns the ephemeral key digit string of length 9 with first 8 digits randomly generated,
              and the last digit as verhoeff checksum.
    -->
    <method name="ActivateEphemeralKeyMode">
      <arg name="lifetime" type="u" direction="in"/>
      <arg name="epskc" type="s" direction="out"/>
    </method>

    <!-- DeactivateEphemeralKeyMode: Deactivate ePSKc mode.
      @retain_active_session: 
        "false" - Disconnects the Border Agent from any active secure sessions.
                  Ephemeral key would be cleared after the session is disconnected.
        "true" - Deactivate ephemeral key mode softly. If there is already an active commissioner
                 connection, the session will be retained and the ephemeral key mode is still active.
    -->
    <method name="DeactivateEphemeralKeyMode">
      <arg name="retain_active_session" type="b" direction="in"/>
    </method>

    <!-- MeshLocalPrefix: The /64 mesh-local prefix.  -->
    <property name="MeshLocalPrefix" type="ay" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LinkMode: The current link mode.
      <literallayout>
      struct {
        bool rx_on_when_idle    //whether the radio receiving is on when idle
        bool device_type        //ftd or mtd
        bool network_data       //full or stable
      }
      </literallayout>
    -->
    <property name="LinkMode" type="(bbb)" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- DeviceRole: The current device role.
      Possible values are:
      <literallayout>
        0: Disabled
        1: Detached
        2: Child
        3: Router
        4: Leader
      </literallayout>
    -->
    <property name="DeviceRole" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>

    <!-- NetworkName: The network name. -->
    <property name="NetworkName" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- PanId: The pan ID. -->
    <property name="PanId" type="q" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ExtPanId: The extended pan ID. -->
    <property name="ExtPanId" type="t" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Channel: The current network channel, from 11 to 26 -->
    <property name="Channel" type="q" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- CcaFailureRate: The Clear Channel Assessment failure rate. -->
    <property name="CcaFailureRate" type="q" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- MacCounters: The mac layer statistic counters.
      The counter structure definition:
      <literallayout>
        struct {
          uint32 tx_total;
          uint32 tx_unicast;
          uint32 tx_broadcast;
          uint32 tx_ack_requested;
          uint32 tx_acked;
          uint32 tx_no_ack_requested;
          uint32 tx_data;
          uint32 tx_data_poll;
          uint32 tx_beacon;
          uint32 tx_beacon_request;
          uint32 tx_other;
          uint32 tx_retry;
          uint32 tx_err_cca;
          uint32 tx_err_abort;
          uint32 tx_busy_channel;
          uint32 rx_total;
          uint32 rx_unicast;
          uint32 rx_broadcast;
          uint32 rx_data;
          uint32 rx_data_poll;
          uint32 rx_beacon;
          uint32 rx_beacon_request;
          uint32 rx_other;
          uint32 rx_address_filtered;
          uint32 rx_dest_address_filtered;
          uint32 rx_duplicated;
          uint32 rx_err_no_frame;
          uint32 rx_err_unknown_neighbor;
          uint32 rx_err_invalid_src_addr;
          uint32 rx_err_sec;
          uint32 rx_err_fcs;
          uint32 rx_err_other;
        }
      </literallayout>
    -->
    <property name="MacCounters" type="(uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LinkCounters: The link statistic counters.
      The counter structure definition:
      <literallayout>
        struct {
          uint32 ip_tx_success;
          uint32 ip_rx_success;
          uint32 ip_tx_failure;
          uint32 ip_rx_failure;
        }
      </literallayout>
    -->
    <property name="LinkCounters" type="(uuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LinkSupportedChannelMask: The bitwise link supported channel mask -->
    <property name="LinkSupportedChannelMask" type="u" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LinkPreferredChannelMask: The bitwise link preferred channel mask -->
    <property name="LinkPreferredChannelMask" type="u" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Rloc16: The 16-bit routing locator -->
    <property name="Rloc16" type="q" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ExtendedAddress: The 64-bit extended address -->
    <property name="ExtendedAddress" type="t" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RouterID: The current router ID -->
    <property name="RouterID" type="y" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LeaderData: The network leader data.
      The structure definition:
      <literallayout>
        struct {
          uint32_t mPartitionId;       // Partition ID
          uint8_t  mWeighting;         // Leader Weight
          uint8_t  mDataVersion;       // Full Network Data Version
          uint8_t  mStableDataVersion; // Stable Network Data Version
          uint8_t  mLeaderRouterId;    // Leader Router ID
        }
      </literallayout>
    -->
    <property name="LeaderData" type="(uyyyy)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- NetworkData: The network data. -->
    <property name="NetworkData" type="ay" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- StableNetworkData: The stable network data. -->
    <property name="StableNetworkData" type="ay" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- LocalLeaderWeight: The leader weight of the current node. -->
    <property name="LocalLeaderWeight" type="y" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ChannelMonitorSampleCount: The number of the collected samples from the channel monitor -->
    <property name="ChannelMonitorSampleCount" type="u" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ChannelMonitorChannelQualityMap: The channel monitor statistics data.
      The structure definition:
      <literallayout>
        struct {
          uint8_t  mChannel;
          uint16_t mOccupancy;
        }
      </literallayout>
    -->
    <property name="ChannelMonitorChannelQualityMap" type="a(yq)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ChildTable: The node's child table as an array of child entry structure.
      The child entry structure definition:
      <literallayout>
        struct {
          uint64_t mExtAddress;         // IEEE 802.15.4 Extended Address
          uint32_t mTimeout;            // Timeout
          uint32_t mAge;                // Time last heard
          uint16_t mRloc16;             // RLOC16
          uint16_t mChildId;            // Child ID
          uint8_t  mNetworkDataVersion; // Network Data Version
          uint8_t  mLinkQualityIn;      // Link Quality In
          int8_t   mAverageRssi;        // Average RSSI
          int8_t   mLastRssi;           // Last observed RSSI
          uint16_t mFrameErrorRate;     // Frame error rate (0xffff->100%). Requires error tracking feature.
          uint16_t mMessageErrorRate;   // (IPv6) msg error rate (0xffff->100%). Requires error tracking feature.
          bool     mRxOnWhenIdle;       // rx-on-when-idle
          bool     mFullThreadDevice;   // Full Thread Device
          bool     mFullNetworkData;    // Full Network Data
          bool     mIsStateRestoring;   // Is in restoring state
        }
      </literallayout>
    -->
    <property name="ChildTable" type="a(tuuqqyyyyqqbbbb)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- NeighborTable: The node's neighbor table as an array of neighbor entry structure.
      The neighbor entry structure definition:
      <literallayout>
        struct {
          uint64_t mExtAddress;        // IEEE 802.15.4 Extended Address
          uint32_t mAge;               // Time last heard
          uint16_t mRloc16;            // RLOC16
          uint32_t mLinkFrameCounter;  // Link Frame Counter
          uint32_t mMleFrameCounter;   // MLE Frame Counter
          uint8_t  mLinkQualityIn;     // Link Quality In
          int8_t   mAverageRssi;       // Average RSSI
          int8_t   mLastRssi;          // Last observed RSSI
          uint16_t mFrameErrorRate;    // Frame error rate (0xffff->100%). Requires error tracking feature.
          uint16_t mMessageErrorRate;  // (IPv6) msg error rate (0xffff->100%). Requires error tracking feature.
          uint16_t mVersion;           // Thread version of the neighbor
          bool     mRxOnWhenIdle;      // rx-on-when-idle
          bool     mFullThreadDevice;  // Full Thread Device
          bool     mFullNetworkData;   // Full Network Data
          bool     mIsChild;           // Is the neighbor a child
        }
      </literallayout>
    -->
    <property name="NeighborTable" type="a(tuquuyyyqqqbbbb)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- PartitionId: The network partition ID. -->
    <property name="PartitionId" type="u" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- InstantRssi: The RSSI of the last received packet. -->
    <property name="InstantRssi" type="y" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RadioTxPower: The radio transmit power. -->
    <property name="RadioTxPower" type="y" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ExternalRoutes: The list of current external route rules.
      External route rule structure definition:
      <literallayout>
        struct {
          struct {
            uint8[] prefix_bytes
            uint8 prefix_length
          }
          uint16 rloc
          uint8 preference
          bool stable
          bool next_hop_is_self
        }
      </literallayout>
    -->
    <property name="ExternalRoutes" type="((ayy)qybb)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- OnMeshPrefixes: The list of current on-mesh prefixes.
      on-mesh prefix structure definition:
      <literallayout>
        struct {
          struct {
            uint8[] prefix_bytes
            uint8 prefix_length
          }
          uint16 rloc
          uint8 preference
          bool is_preferred
          bool is_slaac
          bool is_dhcp
          bool is_configure
          bool is_default_route
          bool is_on_mesh
          bool is_stable
          bool is_nd_dns
          bool is_dp
        }
      </literallayout>
    -->
    <property name="OnMeshPrefixes" type="a((ayy)qybbbbbbbbb)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ActiveDatasetTlvs: The Thread active dataset tlv in binary form. -->
    <property name="ActiveDatasetTlvs" type="ay" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- PendingDatasetTlvs: The Thread pending dataset tlv in binary form. -->
    <property name="PendingDatasetTlvs" type="ay" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

     <!-- FeatureFlagListData: The Thread feature flags (defined as proto/feature_flag.proto)
      in binary form. -->
    <property name="FeatureFlagListData" type="ay" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RadioRegion: The radio region code in ISO 3166-1. -->
    <property name="RadioRegion" type="s" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- SrpServerInfo: The SRP server information.
      <literallayout>
        struct {
          uint8 state
          uint16 port
          uint8 address_mode
          struct {  // hosts
            uint32 fresh_count
            uint32 deleted_count
            uint64 lease_time_total
            uint64 key_lease_time_total
            uint64 remaining_lease_time_total
            uint64 remaining_key_lease_time_total
          }
          struct {  // services
            uint32 fresh_count
            uint32 deleted_count
            uint64 lease_time_total
            uint64 key_lease_time_total
            uint64 remaining_lease_time_total
            uint64 remaining_key_lease_time_total
          }
          struct {  // response counters
            uint32 success
            uint32 server_failure
            uint32 format_error
            uint32 name_exists
            uint32 refused
            uint32 other
          }
        }
      </literallayout>
    -->
    <property name="SrpServerInfo" type="(yqy(uutttt)(uutttt)(uuuuuu))" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>
    <!-- DnssdCounters: The DNS-SD counters
    <literallayout>
        struct {
          uint32 success
          uint32 server_failure
          uint32 format_error
          uint32 name_error
          uint32 not_implemented
          uint32 other
          uint32 resolved_by_srp
        }
      </literallayout>
    -->
    <property name="DnssdCounters" type="(uuuuuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- MdnsTelemetryInfo: The MDNS information
    <literallayout>
        struct {
          struct {  // host registration responses
            uint32 success
            uint32 not_found
            uint32 invalid_args
            uint32 duplicated
            uint32 not_implemented
            uint32 unknown_error
            uint32 aborted
            uint32 invalid_state
          }
          struct {  // service registration responses
            uint32 success
            uint32 not_found
            uint32 invalid_args
            uint32 duplicated
            uint32 not_implemented
            uint32 unknown_error
            uint32 aborted
            uint32 invalid_state
          }
          struct {  // host resolution responses
            uint32 success
            uint32 not_found
            uint32 invalid_args
            uint32 duplicated
            uint32 not_implemented
            uint32 unknown_error
            uint32 aborted
            uint32 invalid_state
          }
          struct {  // service resolution responses
            uint32 success
            uint32 not_found
            uint32 invalid_args
            uint32 duplicated
            uint32 not_implemented
            uint32 unknown_error
            uint32 aborted
            uint32 invalid_state
          }
          uint32 host_registration_ema_latency
          uint32 service_registration_ema_latency
          uint32 host_resolution_ema_latency
          uint32 service_resolution_ema_latency
        }
      </literallayout>
    -->
    <property name="MdnsTelemetryInfo" type="(uuuuuuuu)(uuuuuuuu)(uuuuuuuu)(uuuuuuuu)uuuu" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- OtbrVersion: The version string of the otbr package. -->
    <property name="OtbrVersion" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- OtHostVersion: The version string of the host build. -->
    <property name="OtHostVersion" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- OtRcpVersion: The version string of the RCP firmware. -->
    <property name="OtRcpVersion" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- ThreadVersion: The Thread protocol version. -->
    <property name="ThreadVersion" type="q" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Eui64: The IEEE EUI-64 of this Thread interface. -->
    <property name="Eui64" type="t" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RadioSpinelMetrics: The radio spinel metrics
    <literallayout>
        struct {
          uint32_t mRcpTimeoutCount;         // The number of RCP timeouts.
          uint32_t mRcpUnexpectedResetCount; // The number of RCP unexcepted resets.
          uint32_t mRcpRestorationCount;     // The number of RCP restorations.
          uint32_t mSpinelParseErrorCount;   // The number of spinel frame parse errors.
        }
      </literallayout>
    -->
    <property name="RadioSpinelMetrics" type="(uuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RcpInterfaceMetrics: The RCP interface metrics
    <literallayout>
        struct {
          uint8_t  mRcpInterfaceType;             // The RCP interface type.
          uint64_t mTransferredFrameCount;        // The number of transferred frames.
          uint64_t mTransferredValidFrameCount;   // The number of transferred valid frames.
          uint64_t mTransferredGarbageFrameCount; // The number of transferred garbage frames.
          uint64_t mRxFrameCount;                 // The number of received frames.
          uint64_t mRxFrameByteCount;             // The number of received bytes.
          uint64_t mTxFrameCount;                 // The number of transmitted frames.
          uint64_t mTxFrameByteCount;             // The number of transmitted bytes.
        }
      </literallayout>
    -->
    <property name="RcpInterfaceMetrics" type="(yttttttt)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Uptime: The number of milliseconds since OpenThread instance was initialized. -->
    <property name="Uptime" type="t" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- RadioCoexMetrics: The radio coexistence metrics
    <literallayout>
        struct {
          uint32_t mNumGrantGlitch;                     // Number of grant glitches.
          uint32_t mNumTxRequest;                       // Number of tx requests.
          uint32_t mNumTxGrantImmediate;                // Number of tx requests while grant was active.
          uint32_t mNumTxGrantWait;                     // Number of tx requests while grant was inactive.
          uint32_t mNumTxGrantWaitActivated;            // Number of tx requests while grant was inactive that were ultimately granted.
          uint32_t mNumTxGrantWaitTimeout;              // Number of tx requests while grant was inactive that timed out.
          uint32_t mNumTxGrantDeactivatedDuringRequest; // Number of tx that were in progress when grant was deactivated.
          uint32_t mNumTxDelayedGrant;                  // Number of tx requests that were not granted within 50us.
          uint32_t mAvgTxRequestToGrantTime;            // Average time in usec from tx request to grant.
          uint32_t mNumRxRequest;                       // Number of rx requests.
          uint32_t mNumRxGrantImmediate;                // Number of rx requests while grant was active.
          uint32_t mNumRxGrantWait;                     // Number of rx requests while grant was inactive.
          uint32_t mNumRxGrantWaitActivated;            // Number of rx requests while grant was inactive that were ultimately granted.
          uint32_t mNumRxGrantWaitTimeout;              // Number of rx requests while grant was inactive that timed out.
          uint32_t mNumRxGrantDeactivatedDuringRequest; // Number of rx that were in progress when grant was deactivated.
          uint32_t mNumRxDelayedGrant;                  // Number of rx requests that were not granted within 50us.
          uint32_t mAvgRxRequestToGrantTime;            // Average time in usec from rx request to grant.
          uint32_t mNumRxGrantNone;                     // Number of rx requests that completed without receiving grant.
          bool     mStopped;                            // Stats collection stopped due to saturation.
        }
      </literallayout>
    -->
    <property name="RadioCoexMetrics" type="(uuuuuuuuuuuuuuuuuub)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Nat64State: The state of NAT64
    <literallayout>
        struct {
            string mPrefixManagerState;
            string mTranslatorState;
        }
    </literallayout>
    -->
    <property name="Nat64State" type="(ss)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Nat64Mappings: The state of NAT64
    <literallayout>
        struct
        {
          uint64_t  mId;              // The unique id for a mapping session.
          uint8_t[] mIp4;             // The IPv4 address of the mapping.
          uint8_t[] mIp6;             // The IPv6 address of the mapping.
          uint32_t  mRemainingTimeMs; // Remaining time before expiry in milliseconds.
          struct
          {
            struct
            {
              uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
              uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
              uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
              uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
            } mTotal;                // Counters for sum of all protocols.
            struct
            {
              uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
              uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
              uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
              uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
            } mIcmp;                 // Counters for ICMP and ICMPv6.
            struct
            {
              uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
              uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
              uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
              uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
            } mUdp;                  // Counters for UDP.
            struct
            {
              uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
              uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
              uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
              uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
            } mTcp;                  // Counters for TCP.
          } mCounters;
        }[]
    </literallayout>
    -->
    <property name="Nat64Mappings" type="a(tayayu((tttt)(tttt)(tttt)(tttt)))" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Nat64ProtocolCounters: The state of NAT64
    <literallayout>
        struct
        {
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
            uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
          } mTotal;                // Counters for sum of all protocols.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
            uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
          } mIcmp;                 // Counters for ICMP and ICMPv6.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
            uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
          } mUdp;                  // Counters for UDP.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m4To6Bytes;   // Sum of size of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
            uint64_t m6To4Bytes;   // Sum of size of packets translated from IPv6 to IPv4.
          } mTcp;                  // Counters for TCP.
        }
    </literallayout>
    -->
    <property name="Nat64ProtocolCounters" type="((tttt)(tttt)(tttt)(tttt))" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Nat64ErrorCounters: The state of NAT64
    <literallayout>
        struct
        {
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
          } mUnknown;              // Packet drop for unknown reasons.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
          } mIllegalPacket;        // Packet drop due to failed to parse the datagram.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
          } mUnsupportedProto;     // Packet drop due to unsupported IP protocol.
          struct
          {
            uint64_t m4To6Packets; // Number of packets translated from IPv4 to IPv6.
            uint64_t m6To4Packets; // Number of packets translated from IPv6 to IPv4.
          } mNoMapping;            // Packet drop due to no mappings found or mapping pool exhausted.
        }
    </literallayout>
    -->
    <property name="Nat64ErrorCounters" type="((tt)(tt)(tt)(tt))" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Nat64Cidr: The CIDR used for NAT64 -->
    <property name="Nat64Cidr" type="s" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- BorderRoutingCounters: The counters for inbound/outbound packets
    <literallayout>
        struct {
          struct {  // inbound unicast
            uint64 packets
            uint64 bytes
          }
          struct {  // inbound multicast
            uint64 packets
            uint64 bytes
          }
          struct {  // outbound unicast
            uint64 packets
            uint64 bytes
          }
          struct {  // outbound multicast
            uint64 packets
            uint64 bytes
          }
          uint32  ra_rx;              // The number of received RA packets.
          uint32  ra_tx_success;      // The number of RA packets successfully transmitted.
          uint32  ra_tx_failure;      // The number of RA packets failed to transmit.
          uint32  rs_rx;              // The number of received RS packets.
          uint32  rs_tx_success;      // The number of RS packets successfully transmitted.
          uint32  rs_tx_failure;      // The number of RS packets failed to transmit.
        }
    </literallayout>
    -->
    <property name="BorderRoutingCounters" type="((tt)(tt)(tt)(tt)uuuuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- InfraLinkInfo: Information of infrastructure network interface.
    <literallayout>
        struct {
          string name;                     // The name of the infrastructure network interface.
          bool   is_up;                    // Whether the infrastructure network interface is up.
          bool   is_running;               // Whether the infrastructure network interface is running.
          bool   is_multicast;             // Whether the infrastructure network interface is multicast.
          uint32 link_local_addresses      // The number of link-local addresses on the infra network interface.
          uint32 unique_local_addresses    // The number of unique local addresses on the infra network interface.
          uint32 global_unicast_addresses  // The number of global unicast addresses on the infra network interface.
        }
    </literallayout>
    -->
    <property name="InfraLinkInfo" type="(sbbbuuu)" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- DnsUpstreamQueryState: Whether the server will / should forward DNS queries platform
    specified upstream DNS servers. -->
    <property name="DnsUpstreamQueryState" type="b" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- TelemetryData: The Thread telemetry data (defined as proto/thread_telemetry.proto)
      in binary form. -->
    <property name="TelemetryData" type="ay" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- Capabilities: The Thread capabilities data (defined as proto/capabilities.proto)
      in binary form. -->
    <property name="Capabilities" type="ay" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>

    <!-- The Ready signal is sent on start -->
    <signal name="Ready">
    </signal>

  </interface>

  <interface name="org.freedesktop.DBus.Properties">
    <method name="Get">
      <arg name="interface" direction="in" type="s"/>
      <arg name="property" direction="in" type="s"/>
      <arg name="value" direction="out" type="v"/>
    </method>

    <method name="GetAll">
      <arg name="interface" direction="in" type="s"/>
      <arg name="properties" direction="out" type="a{sv}"/>
    </method>

    <method name="Set">
      <arg name="interface" direction="in" type="s"/>
      <arg name="property" direction="in" type="s"/>
      <arg name="value" direction="in" type="v"/>
    </method>

    <signal name="PropertiesChanged">
      <arg type="s" name="interface"/>
      <arg type="a{sv}" name="changed_properties"/>
      <arg type="as" name="invalidated_properties"/>
    </signal>
  </interface>
</node>
