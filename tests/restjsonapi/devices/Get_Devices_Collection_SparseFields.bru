meta {
  name: Get Devices Collection SparseFields
  type: http
  seq: 1
}

get {
  url: {{protocol}}://{{host}}:{{port}}{{base_path}}/devices?fields[threadBorderRouter]=extAddress,mlEidIid
  body: none
  auth: none
}

query {
  fields[threadBorderRouter]: extAddress,mlEidIid
}

headers {
  Accept: application/vnd.api+json
}

assert {
  res.headers['content-type']: eq application/vnd.api+json
  res.body: isJson
  res.status: eq 200
  res.body.meta.collection: isDefined
  res.body.meta.collection.total: gte 1
  res.body.data: isDefined
  res.body.data[0].id: isDefined
  res.body.data[0].type: neq ""
  res.body.data[0].attributes.created: isDefined
}

tests {
  test("Data contains fields requested", function() {
    const data = res.getBody().data;
    const offset = res.getBody().meta.collection.offset;
    const limit = res.getBody().meta.collection.limit;
    const total = res.getBody().meta.collection.total;
    
    expect(data).to.be.an.instanceOf(Array);
    expect(offset).to.be.a('number');
    expect(limit).to.be.a('number');
    expect(total).to.be.a('number');
    
    for (let i=0; i < data.length; i++){
      let item = data[i];
      
      expect(item, `Item at index ${i}/${data.length} is null or undefined`).to.exist;
  
      expect(item).to.have.property("id");
      expect(item).to.have.property("type");
      expect(item.type).to.be.oneOf(["threadDevice", "threadBorderRouter"]);
      expect(item).to.have.property("attributes");
      expect(item.attributes).to.have.property("extAddress").that.is.not.oneOf([""]);
      expect(item.attributes).to.have.property("mlEidIid").that.is.not.oneOf([""]);
      expect(item.attributes).to.not.have.property("omrIpv6Address").that.is.not.oneOf(["", "::"]);
      expect(item.attributes).to.not.have.property("eui64").that.is.not.oneOf([""]);
      expect(item.attributes).to.not.have.property("hostName");
      expect(item.attributes).to.have.property("created").that.is.not.empty;
    }
  });
}

docs {
  Returns basic static device attributes.
  On first GET request, requests diagnostic TLVs from each device,
  otherwise returns buffered filtered information.
}
